'use strict';

const fs = require('fs');
const path = require('path');
const Module = require('module');

class PackageFinder {
  /**
   * Resolves the metadata of a package, given it's resolved name. Additional
   * options can be supplied to customize the search process.
   * @param {Object} params
   * @param {string} params.resolvedName Absolute path to the module file
   * @param {string} [params.file=package.json] allow to pass in for testing purposes
   * @param {Module} params.parentModule original Module before we started patching it
   * @param {Function} [params.origRequire=Module.prototype.require] used to read the package.json for a given module
   * @returns {Object}
   */
  static resolveMetadata({
    logger = console,
    parentModule,
    origRequire = Module.prototype.require,
    resolvedName,
    file = 'package.json'
  } = {}) {
    if (PackageFinder.isNative(resolvedName)) {
      return { version: process.version.substring(1), name: resolvedName };
    }

    const metadata = {};

    if (!resolvedName) {
      return metadata;
    }

    let rootDir = resolvedName;
    const totalIterations = resolvedName.split(path.sep).length - 1;

    for (let i = 1; i <= totalIterations; i++) {
      rootDir = path.dirname(rootDir);

      const filePath = path.resolve(rootDir, file);

      if (!fs.existsSync(filePath)) {
        continue;
      }

      try {
        // Use the require that was created before we started patching it
        // bind it with the original Module(parentModule)
        const { name, version } = origRequire.call(parentModule, filePath);
        return {
          name,
          version,
          packageDir: rootDir
        };
      } catch (err) {
        logger.error('Unable to parse %s, err: %o', filePath, err);
        break;
      }
    }

    return metadata;
  }

  /**
   *
   * @param {string} name
   * @returns {Boolean}
   */
  static isNative(name) {
    return name in process.binding('natives');
  }
}

module.exports = PackageFinder;
