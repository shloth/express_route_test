'use strict';

const EventEmitter = require('events');
const Module = require('module');
const semver = require('semver');
const { get } = require('lodash');

const PackageFinder = require('./package-finder');

const ERR_RESOLVE_FILENAME = 'ERR_RESOLVE_FILENAME';

class ExportHandlerRegistry extends EventEmitter {
  /**
   * Instantiates the export handler registry.
   * This leverages DI to make it easier to test without
   * proxying mocks
   * @param {Object} params
   * @param {Object} [params.origModule={resolveFileName: Module._resolveFilename, require: Module.prototype.require }]
   * @param {Function} [params.resolveMeta=PackageFinder.resolveMeta]
   *
   */
  constructor({
    logger,
    origModule = {
      resolveFilename: Module._resolveFilename,
      require: Module.prototype.require
    },
    resolveMetadata = PackageFinder.resolveMetadata
  } = {}) {
    super();

    this.logger = logger;
    this.resolveFilename = origModule.resolveFilename;
    this.require = origModule.require;
    this.resolveMetadata = resolveMetadata;
    // contains all modules that have been resolved and are in require cache
    this.resolved = {};
    // contains instrumentation handlers
    this.registered = {};
    this.filenameToRegistered = {};
  }

  /**
   * Update the registry with the handler info for the given module name.
   * This gets called when an agent registers a handler for a given module.
   * @param {string} name
   * @param {Object} handlerInfo
   * @param {string} handlerInfo.file
   * @param {Function[]} handlerInfo.handlers
   * @param {string} handlerInfo.version
   */
  update(name, handlerInfo) {
    if (!this.registered[name]) {
      this.registered[name] = [handlerInfo];
    } else {
      this.registered[name].push(handlerInfo);
    }

    return this.registered[name];
  }

  /**
   * When an export is returned from a `require`, we want to resolve the name
   * used as the param, e.g. "http" in `require('http')`, to a set of
   * metadata and handlers that have been registerted for exports by that name.
   * @param {string} name The module name
   * @param {string} resolvedName Absolute path of the module's file
   * @param {Module} parentModule Module instance in which `require` was called
   * @returns {Object|null}
   */
  query(name, parentModule) {
    const resolvedName = this.resolveFilename(name, parentModule, false);

    const registered = this.findRegisteredHandlerData(name, resolvedName);

    if (!registered) {
      return;
    }

    const metadata = this.resolveMetadata({
      logger: this.logger,
      parentModule,
      origRequire: this.require,
      resolvedName
    });

    this.buildFromRegistry({
      name,
      metadata,
      parentModule,
      registered,
      resolvedName
    });

    return this.findModuleHandlerData({ name, resolvedName, metadata });
  }

  /**
   *  Returns an array of handlers that have been registered for a given module
   *
   *  @param {string} name module name
   *  @param {string} resolvedName full path to module
   *  @return {Array}
   */
  findRegisteredHandlerData(name, resolvedName) {
    return this.registered[name] || this.filenameToRegistered[resolvedName];
  }

  /**
   * Returns registered handlers and the module metadata(version,name, path)
   * for a module that has registration for the version that is being required
   *
   * @param {Object} params
   * @param {string} params.name module name
   * @param {string} params.resolvedName full path to module
   * @param {Object} params.metadata module metadata
   * @return {Object} { handlers: [<instrumentation handlers>], metadata: <module name, version and path> }
   */
  findModuleHandlerData({ name, resolvedName, metadata }) {
    const module = this.resolved[name] || this.resolved[resolvedName];

    // Need to check the version of the instrumentation handler to the one getting required
    // to decide if we need they are version applicable
    if (
      module &&
      get(metadata, 'version') === get(module, 'metadata.version')
    ) {
      return module;
    }
  }

  /**
   * Iterates all descriptors pertaining to the currently-loading export. It
   * builds into the set of resolved paths the metadata and handlers for each
   * handler that is applicable to the export. If filepaths are present in the
   * descriptor, the metadata and handlers will be set for those files' absolute
   * paths as well.
   * @param {string} options.name
   * @param {Object} options.metadata
   * @param {Module} options.parentModule
   * @param {Object} options.registered
   * @param {string} options.resolvedName
   */
  buildFromRegistry({
    name,
    metadata,
    parentModule,
    registered,
    resolvedName
  }) {
    const fileHandlers = {};
    for (const info of registered) {
      if (!this.isProperVersion(metadata, info)) {
        continue;
      }

      const { handlers } = info;

      if (info.file) {
        const relativeFile = `${name}/${info.file}`;

        try {
          const absoluteFile = this.resolveFilename(
            relativeFile,
            parentModule,
            false
          );
          setOrAddInfo(fileHandlers, absoluteFile, { metadata, handlers });
          if (!this.filenameToRegistered[absoluteFile]) {
            this.filenameToRegistered[absoluteFile] = [];
          }

          this.filenameToRegistered[absoluteFile].append(info);
        } catch (error) {
          this.emit(ERR_RESOLVE_FILENAME, { name, relativeFile });
        }
      } else {
        setOrAddInfo(fileHandlers, name, { metadata, handlers });
      }
    }

    for (const file in fileHandlers) {
      this.resolved[file] = fileHandlers[file];
    }
  }

  /**
   * Checks if package version matches resolved version
   * @param {Object} metadata package meta
   * @param {*} module resolved xport of module
   */
  isProperVersion(metadata = {}, module = {}) {
    return semver.satisfies(metadata.version, module.version);
  }
}

/**
 * Sets a property on the target using the provided path parameter that is a
 * collection containing the provided data. If the property already exists, then
 * the data will be added to the collection.
 * @param {Object} target The object on which to add the property
 * @param {string} path The string used to name the property path
 * @param {*} data Data to add to the collection at the path
 */
const setOrAddInfo = (target, path, data) => {
  const { handlers } = data;
  if (!target[path]) {
    target[path] = data;
  } else {
    [].push.apply(target[path].handlers, handlers);
  }
};

module.exports = ExportHandlerRegistry;
module.exports.ERRORS = { ERR_RESOLVE_FILENAME };
module.exports.HandlerRegistry = ExportHandlerRegistry;
module.exports.setOrAddInfo = setOrAddInfo;
