'use strict';

const EventEmitter = require('events');
const Module = require('module');

const ExportDescriptor = require('./export-hook-descriptor');
const HandlerInvoker = require('./handler-invoker');
const {
  HandlerRegistry,
  ERRORS: { ERR_RESOLVE_FILENAME }
} = require('./export-handler-registry');

/**
 * Allows clients to register function handlers witch run as a "post-hook" on
 * module methods such as <code>require</code>.
 */
class RequireHook extends EventEmitter {
  constructor(logger) {
    super();

    // set this up before we start patching moulde methods
    this.origModule = {
      require: Module.prototype.require,
      resolveFilename: Module._resolveFilename
    };
    this.invoker = new HandlerInvoker();
    this.registry = new HandlerRegistry({
      logger,
      origModule: this.origModule
    });
    this.requiredModules = new WeakMap();
    this.resets = new Set();

    this.init();
  }

  /**
   * Initialization logic.
   */
  init() {
    this.install(Module.prototype);

    // Just forward the error
    this.registry.on(ERR_RESOLVE_FILENAME, (eventArgs) => {
      this.emit(ERR_RESOLVE_FILENAME, eventArgs);
    });
  }

  /**
   * Registers handlers to run afer the described module is `required`'d.
   * @param {Object|string} descriptor Describes the module
   * @param {Function} handler... The function handlers to execute
   */
  resolve(...args /*, handler, ... */) {
    const [descriptor, ...handlers] = args;
    const { file, name, version } = RequireHook.normalizeDescriptor(descriptor);
    const info = ExportDescriptor.create({ file, handlers, name, version });

    this.registry.update(name, info);
  }

  /**
   * Provided with an export, a collection of handlers, and metadata, will
   * invoke only the handlers which have not yet run on the export instance.
   * @param {Function[]} handlers Handlers to run
   * @param {Object} metadata The export's metadata
   * @param {*} xport The export
   * @returns {*}
   */
  runRequireHandlers(handlers, metadata, xport) {
    return this.invoker.invoke(handlers, xport, metadata);
  }

  /**
   * Advises the <code>require</code> method to run registered handlers _after_
   * the modules have been `require`'d.
   * @param {Object} proto The `Module.prototype`.
   * @returns {*} The export value of a <code>require</code> call
   */
  install(proto) {
    const self = this;

    proto.require = function(...args) {
      const [name] = args;
      let xportSubstitution;

      const exportHandlerInfo = self.registry.query(name, this);
      const xport = Reflect.apply(self.origModule.require, this, args);

      if (exportHandlerInfo) {
        self.maybeClearHandlers(name, xport);

        xportSubstitution = self.runRequireHandlers(
          exportHandlerInfo.handlers,
          exportHandlerInfo.metadata,
          self.requiredModules.get(xport) || xport
        );

        self.requiredModules.set(xport, xportSubstitution);
      }

      return self.requiredModules.get(xport) || xport;
    };
  }

  /**
   * Checks if module name exists in resets Set.  If so,
   * it will remove from set as well as remove from the invoker WeakMap
   * This will force instrumentation handlers to re-run. This use
   * case is only used for testing of the node agent in certain cases
   *
   * @param {string} name The module name
   * @param {*} The export value of a required module
   */
  maybeClearHandlers(name, xport) {
    if (this.resets.has(name)) {
      this.resets.delete(name);
      this.invoker.reset(xport);
    }
  }

  /**
   * Resets the module's prototype methods to their original values.
   */
  uninstall() {
    Module.prototype.require = this.origModule.require;
    this.origModule.require = null;
  }

  /**
   * Resets the seen handlers for a given module - they will be
   * re-run on next require
   */
  reset(name) {
    this.resets.add(name);
  }

  /**
   * Coerces a string into a minimal object that can be made into a descriptor.
   * @param {string|Object} descriptor The export descriptor
   * @returns {Object}
   */
  static normalizeDescriptor(descriptor) {
    if (typeof descriptor === 'string') {
      return { name: descriptor };
    }

    if (descriptor.module) {
      descriptor.name = descriptor.module;
    }

    return descriptor;
  }
}

module.exports = RequireHook;
